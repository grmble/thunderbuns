-- | Thunderbuns.WebAPI
--
-- This used to be autogenerated by servant-purescript,
-- but only purescript-bridge works with purescript 0.12
-- as of now, so this is hand coded
--
-- Argonaut Codecs generics is not ready yet either,
-- so we are faking argonaut codecs via foreign-generic
module Thunderbuns.WebAPI where

import Prelude

import Bonsai.DOM (affF, effF)
import Control.Monad.Reader (asks)
import Control.Monad.Reader.Class (class MonadReader)
import Data.Argonaut.Core (Json)
import Data.Either (Either(..))
import Data.Generic.Rep (class Generic)
import Data.Generic.Rep.Show (genericShow)
import Data.HTTP.Method (Method(..))
import Data.Lens (Lens', view)
import Data.Lens.Iso (Iso', iso)
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Maybe (Maybe(..), maybe)
import Data.Newtype (class Newtype, unwrap)
import Data.Symbol (SProxy(..))
import Data.Traversable (traverse)
import Data.Tuple (Tuple)
import Effect (Effect)
import Effect.Aff.Class (class MonadAff, liftAff)
import Foreign (Foreign, readArray, readString)
import Foreign.Generic (defaultOptions, genericDecode, genericEncode, genericDecodeJSON)
import Foreign.Generic.Class (class GenericEncode, class GenericDecode)
import Foreign.Generic.Types (Options)
import Foreign.Index ((!))
import Global.Unsafe (unsafeEncodeURIComponent)
import Network.HTTP.Affjax (URL, affjax, defaultRequest, post)
import Network.HTTP.Affjax.Request as ARq
import Network.HTTP.Affjax.Response as ARs
import Network.HTTP.RequestHeader as RH
import Thunderbuns.WebAPI.OrderedUUID (OrderedUUID(..))
import Thunderbuns.WebAPI.Types (Channel(..), Msg, NewMsg, Priority, Token, UserPass)
import Thunderfront.Types (Model)
import Unsafe.Coerce (unsafeCoerce)

newtype ApiParams
  = ApiParams
    { authorization :: String
    , baseURL :: String
    }

derive instance newtypeApiParams :: Newtype ApiParams _
derive instance genericApiParams :: Generic ApiParams _
instance showApiParams :: Show ApiParams where show = genericShow

instance hasApiParamsModel :: HasApiParams Model where
  apiParams = _Newtype <<< prop (SProxy :: SProxy "jwtToken") <<< jwtTokenApiParams "/"

jwtTokenApiParams :: String -> Iso' (Maybe String) ApiParams
jwtTokenApiParams rootURL =
  iso (maybe (mkap "") mkap) (sToM  <<< _.authorization <<< unwrap)
  where
    mkap a = ApiParams { authorization: a, baseURL: rootURL }
    sToM s = if s == "" then Nothing else Just s

authorization :: Lens' ApiParams String
authorization = _Newtype <<< prop (SProxy :: SProxy "authorization")

baseURL :: Lens' ApiParams URL
baseURL = _Newtype <<< prop (SProxy :: SProxy "baseURL")

gOpts :: Options
gOpts = defaultOptions { unwrapSingleConstructors = true }

gEncode :: forall a rep. Generic a rep => GenericEncode rep => a -> Json
gEncode a = unsafeCoerce $ genericEncode gOpts a

gDecode :: forall a rep m. Generic a rep => GenericDecode rep => MonadAff m => Json -> m a
gDecode json = liftAff $ affF $ genericDecode gOpts (unsafeCoerce json)

gDecodeArray :: forall a rep m. Generic a rep => GenericDecode rep => MonadAff m => Json -> m (Array a)
gDecodeArray json = liftAff $ affF $ do
  arr <- readArray (unsafeCoerce json)
  traverse (genericDecode gOpts) arr

gDecodeEvent :: forall a rep. Generic a rep => GenericDecode rep => Foreign -> Effect a
gDecodeEvent ev = do
  effF $ (ev ! "data") >>= readString >>= genericDecodeJSON gOpts

urlPath :: String -> URL
urlPath = unsafeEncodeURIComponent

class HasApiParams a where
  apiParams :: Lens' a ApiParams
instance hasApiParamsApiParams :: HasApiParams ApiParams where
  apiParams = identity

requestURL :: forall r m. HasApiParams r => MonadReader r m => URL -> m URL
requestURL url =
  asks (view $ apiParams <<< baseURL) >>=
  (\b -> pure $ b <> url)

authHeader :: forall r m. HasApiParams r => MonadReader r m => m String
authHeader =
  asks (view $ apiParams <<< authorization) >>=
  (\a -> pure $ "Bearer " <> a)


postAuth :: forall r m. HasApiParams r => MonadReader r m => MonadAff m => UserPass -> m Token
postAuth body = do
  url <- requestURL "auth"
  rsp <- liftAff $ post ARs.json url (ARq.json (gEncode body))
  gDecode rsp.response


getChannel :: forall r m. HasApiParams r => MonadReader r m => MonadAff m => m (Array Channel)
getChannel = do
  url <- requestURL "channel"
  auth <- authHeader
  rsp <- liftAff $ affjax ARs.json $
    defaultRequest { method = Left GET
                   , url = url
                   , headers = [ RH.RequestHeader "authorization" auth ]
                   , content = Nothing }
  gDecodeArray rsp.response


putChannel :: forall r m. HasApiParams r => MonadReader r m => MonadAff m => Channel -> m Unit
putChannel body = do
  url <- requestURL "channel"
  auth <- authHeader
  _ <- liftAff $ affjax ARs.ignore $
       defaultRequest { method = Left PUT
                   , url = url
                   , headers = [ RH.RequestHeader "authorization" auth ]
                   , content = Just (ARq.json $ gEncode body) }
  pure unit


getChannelByChannel :: forall r m. HasApiParams r => MonadReader r m => MonadAff m => Channel -> m (Array Msg)
getChannelByChannel (Channel channel) = do
  url <- requestURL "channel/"
  auth <- authHeader
  rsp <- liftAff $ affjax ARs.json $
    defaultRequest { method = Left GET
                   , url = url <> urlPath channel.channelName
                   , headers = [ RH.RequestHeader "authorization" auth ]
                   , content = Nothing }
  gDecodeArray rsp.response

getChannelBefore :: forall r m. HasApiParams r => MonadReader r m => MonadAff m => Channel -> OrderedUUID -> m (Array Msg)
getChannelBefore (Channel channel) (OrderedUUID created) = do
  url <- requestURL "channel/"
  auth <- authHeader
  rsp <- liftAff $ affjax ARs.json $
    defaultRequest { method = Left GET
                   , url = url <> urlPath channel.channelName <> "/before/" <> urlPath created
                   , headers = [ RH.RequestHeader "authorization" auth ]
                   , content = Nothing }
  gDecodeArray rsp.response

putChannelByChannel :: forall r m. HasApiParams r => MonadReader r m => MonadAff m => NewMsg -> Channel -> m Unit
putChannelByChannel body (Channel channel) = do
  url <- requestURL "channel/"
  auth <- authHeader
  _ <- liftAff $ affjax ARs.ignore $
       defaultRequest { method = Left PUT
                   , url = url <> urlPath channel.channelName
                   , headers = [ RH.RequestHeader "authorization" auth ]
                   , content = Just (ARq.json $ gEncode body) }
  pure unit

getDebug :: forall r m. HasApiParams r => MonadReader r m => MonadAff m => m (Array (Tuple String (Maybe Priority)))
getDebug = pure []

postDebug :: forall r m. HasApiParams r => MonadReader r m => MonadAff m => Array (Tuple String (Maybe Priority)) -> m Unit
postDebug reqBody = pure unit
